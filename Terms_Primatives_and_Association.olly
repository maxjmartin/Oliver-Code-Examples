############################################################
# All data in Oliver is represented either as a term
# an expression, or as an abstraction.  All expressions
# are defined by a bounding pair of characters that define
# the start and the end of the expression.
############################################################

# Number expressions are bound by apostrophes.
'1', '2', '14.125', '9+3i'

# Text string expressions are bound by quotations.
"a", "b", "Hello", "Welcome to Oliver Lang!"

# Primative expressions are all bound by parenthesis.
(), ('1'), ('1', '2', "cat", "dog", ...)

# They can also be bound by colons.  This is to help 
# reading and organizing written code strings.
:;, :'1';, :'1', '2', "cat", "dog", ...;

# Terms are not bounded by an associated type of character.
# The terms below are commented out so as to not invooke 
# their associated expression.
#   _STACK_, EMIT, double, add_two, clear

# Keyword terms, all have a predefined expression associatation.
_STACK_         # Set a copy of the stack on top of the stack.
EMIT            # Print a text representation of the top stack element.
ENDL            # End the current output string line and flush the output stream.
clear _STACK_   # Prefix operator that clears the contents of a collection.
ENDL            # In this case the runtime _STACK_ was cleared. 

# Reification at runtime repalces all terms with the associated
# expression assign to them.  Terms without associattion will
# alway reify to the value of nothing.  

# Programer defined terms only have an association if 
# and only if an association is defined.  The postfix
# LET operator defines that association.  
@ string_1 "Text string 1." LET
@ string_2 "Text string 2." LET
@ x '42' LET
@ y '18' LET

# Notice the term @ was used.  @ is the identy function.
# @ accepts any single argument and returns it as the 
# result.  It is useful in preventing something from 
# being evaluated at runtime.  Else the reified term
# would be placed on the stack.  The symbol '@' is used
# so as to contextuly read 'at' term / expression.

# Once a term is symbolicly associated, any instance of
# the term will be replaced by its associated expression.
x EMIT ENDL
y EMIT ENDL
string_1 EMIT ENDL
string_2 EMIT ENDL
ENDL

# We can also define new expressions to evaluate using
# the identiy function to associate expressions to terms.
@ add (@ (x + y)) LET
add EMIT ENDL

# Notice that LET requires a single expression to be
# associated.  Therefore we encapsulate the expression
# to associate within another expression.  Expressions
# are all evaluated at runtime immediatley.  Creating
# the same behavior we expect in algebra.
(x + (x / y)) * x EMIT ENDL

############################################################
# Term and expression association can also be performed
# using the prefix 'let' operator. 
############################################################

let x = '42'
let y = '8'
(x + y) EMIT ENDL

# Multiple associations can be done at the same time with let.
# The requirement is that both sides must be expressions.
# If both sides are not equal in size, and extra right hand
# expressions are lost, and any extra left hand associations
# default to nothing.  
let (x, y) = ('2', '3', '6')
(x + y) EMIT ENDL
x EMIT ENDL
y EMIT ENDL